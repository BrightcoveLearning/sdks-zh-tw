---
title: '使用適用於 iOS 的本機 SDK 的代碼片段' 
description:在本主題中，您將找到一系列代碼片段，這些片段在使用SDK進行開發時可用作參考。有關更詳細的解決方案，請參閱<a href="https://github.com/BrightcoveOS/ios-player-samples">iOS 播放器示例</a> .
parent: Resources 
grandparent: iOS Development
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <!-- The next tab set will be 41 and 42 -->

<section class="bcls-section" id="top">
<h3>目錄</h3>
<!-- <h5 class="bcls-question">Accessibility</h5>

<ul class="bcls-answer">
	<li><a href="#VoiceOver_support">VoiceOver support</a></li>
</ul> -->
<details style="padding:0;">
    <summary>廣告</summary>
   <ul>
      <li><a href="#Media_progress_values">媒體進度值</a></li>
    </ul>
</details> 
<br/>

<details style="padding:0;">
    <summary>分析</summary>
    <ul>
      <li><a href="#Google_Analytics">谷歌分析</a></li>
    </ul>
</details>
<br/>

<details style="padding:0;">
    <summary>字幕</summary>
    <ul>
      <li><a href="#Customizing_the_closed_captions_button">自定義隱藏式字幕按鈕</a></li>
      <li><a href="#Modifying_captions_programmatically">以編程方式修改字幕</a></li>
    </ul>
</details>
<br/>

<details style="padding:0;">
    <summary>內容安全性（DRM）</summary>
   <ul>
      <li><a href="#Displaying_FairPlay_content_on_an_external_screen">在外部屏幕上顯示FairPlay內容</a></li>
    </ul>
</details>
<br/>

<details style="padding:0;">
    <summary>提示點</summary>
    <ul>
      <li><a href="#Programmatically_adding_cue_points">以編程方式添加提示點</a></li>
    </ul>
</details>
<br/>

<details style="padding:0;">
    <summary>播放</summary>
    <ul>
      <li><a href="#Custom_controls_for_AirPlay">AirPlay的自定義控件</a></li>
      <li><a href="#Limiting_the_bitrate">限制比特率</a></li>
      <li><a href="#Looping_a_video">循環播放視頻</a></li>
      <li><a href="#Media_progress_values">媒體進度值</a></li>
      <!-- <li><a href="#Setting_the_buffer_size">Setting the buffer size</a></li> -->
      <li><a href="#Paging_with_the_Playback_API">使用播放API分頁</a></li>
      <li><a href="#Removing_the_player">卸下播放器</a></li>
      <li><a href="#Setting_audio_behavior">設置音頻行為</a></li>
      <li><a href="#Setting_the_playback_rate">設置播放速率</a></li>
      <li><a href="#Setting_VR_Goggles_mode_for_360_videos">為 360° 視頻設置 VR Goggles 模式</a></li>
    </ul>
</details>
<br/>

<details style="padding:0;">
    <summary>播放清單</summary>
   <ul>
      <li><a href="#Managing_videos_in_a_playlist">管理播放列表中的視頻</a></li>
    </ul>
</details>
<br/>

<details style="padding:0;">
    <summary>造型</summary>
    <ul>
      <li><a href="#Changing_the_background_color">更改背景顏色</a></li>
    </ul>
</details>
<br/>
</section>

<section class="bcls-section">
<h2 id="Custom_controls_for_AirPlay">AirPlay的自定義控件</h2>

<p>如果您使用<a href="/ios/reference/sdk/index.html#PlayerUI">Brightcove PlayerUI控件</a>，您都準備好了。AirPlay功能是開箱即用的，允許用戶使用Apple TV將視頻流傳輸到高清顯示器。</p>

<p>如果使用自定義控件，則可以按照以下步驟操作：</p>

<ol class="bcls-tasklist-restart">
	<li>
	<p>了解有關AirPlay的信息<a href="">Apple的AirPlay開發人員文檔</a>。</p>
	</li>
	<li>
	<p>使用播放控制器的<code translate="No">allowsExternalPlayback </code>設置 AVPlayer 的屬性<code translate="No">allowsExternalPlayback </code>財產：</p>

  <!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab1">對象</a></li>
      <li><a href="#tab2">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab1" class="tab active">
        <pre>
    <code class="language-objectivec" translate="No">_playbackController.allowsExternalPlayback = YES;</code></pre>
      </div>
      <div id="tab2" class="tab">
        <pre>
    <code class="language-swift" translate="No">playbackController.allowsExternalPlayback = true</code></pre>
      </div>
    </div>
  </div>
  <!-- end tabs -->

	</li>
	<li>
	<p>設置 AirPlay 路由器控件並處理其選擇。有關詳細信息，請參見<a href="https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AirPlayGuide/Introduction/Introduction.html">蘋果的AirPlay概述</a>文檔。</p>
	</li>
</ol>
<h4>參考</h4>
  <p>有關詳細信息，請參見<a href="/ios/reference/sdk/Protocols/BCOVPlaybackController.html#//api/name/allowsExternalPlayback">BCOVPlaybackController</a>文檔。</p>
</section>

<section class="bcls-section">
<h2 id="Customizing_the_closed_captions_button">自定義隱藏式字幕按鈕</h2>

<p>這<a href="/ios/reference/sdk/index.html#PlayerUI">BCOVPlayerUI 示例代碼</a>向您展示如何在使用適用於 iOS 的 Native SDK 時自定義 Brightcove 播放器。有關更多詳細信息，請參見<a href="/ios/reference/sdk/index.html#PlayerUI">自定義PlayerUI控件</a>本機SDK參考文檔的“部分"。</p>

<p>要使用 PlayerUI 自定義隱藏式字幕按鈕，請按照下列步驟操作：</p>

<ol class="bcls-tasklist-restart">
	<li>
	<p>從<a href="https://github.com/BrightcoveOS/ios-player-samples/tree/master/Player/VideoCloudBasicPlayer">基本視頻播放應用程序</a> .</p>
	</li>
	<li>
	<p>將您的值替換為“策略密鑰"，“帳戶ID"和“視頻ID"。從您的帳戶中選擇一個具有文本軌道的視頻。</p>
	</li>
	<li>
	<p>使用標準 VOD 佈局設置播放器視圖：</p>
  <!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab3">對象</a></li>
      <li><a href="#tab4">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab3" class="tab active">
       <pre class="line-numbers">
<code class="language-objectivec" translate="No">// Set up our player view. Create with a standard VOD layout.
BCOVPUIPlayerView *playerView = [[BCOVPUIPlayerView alloc] 
initWithPlaybackController:self.playbackController options:nil controlsView:
[BCOVPUIBasicControlView basicControlViewWithVODLayout] ];</code></pre>
      </div>
      <div id="tab4" class="tab">
        <pre>
<code class="language-swift" translate="No">// Set up our player view. Create with a standard VOD layout.
guard let playerView = BCOVPUIPlayerView(playbackController: 
self.playbackController, options: options, controlsView: 
BCOVPUIBasicControlView.withVODLayout()) else {    
  return
}</code></pre>
      </div>
    </div>
  </div>
  <!-- end tabs -->

	
	</li>
	<li>
	<p>這<code translate="No">closedCaptionButton</code>被聲明為<code translate="No">BCOVPUIButton</code>，它是的子類<code translate="No">UIButton</code>並添加了三種額外的自定義方法。每當您自定義 BCOVPlayerUI 控件時，您都應該使用本機播放器 API，只要它們可用。您的自定義代碼應類似於以下內容：</p>

  <!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab5">對象</a></li>
      <li><a href="#tab6">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab5" class="tab active">
       <pre class="line-numbers">
<code class="language-objectivec" translate="No">// Customize the CC button.
BCOVPUIButton *ccButton = playerView.controlsView.closedCaptionButton;
ccButton.titleLabel.font = [UIFont systemFontOfSize:14.];
ccButton.primaryTitle = @&quot;CC&quot;;
[ccButton showPrimaryTitle:YES];</code></pre>
      </div>
      <div id="tab6" class="tab">
        <pre>
<code class="language-swift" translate="No">if let ccButton = playerView.controlsView.closedCaptionButton {    
  ccButton.titleLabel?.font = UIFont.systemFont(ofSize: 14)    
  ccButton.primaryTitle = &quot;CC&quot;    
  ccButton.showPrimaryTitle(true)}
}</code></pre>
      </div>
    </div>
  </div>
  <!-- end tabs -->

	</li>
</ol>
</section>

<section class="bcls-section">
<h2 id="Displaying_FairPlay_content_on_an_external_screen">在外部屏幕上顯示FairPlay內容</h2>

<p>當使用 AV 適配器和 HDMI 電纜將外部顯示器連接到 iOS 設備時，默認行為是鏡像 iOS 屏幕。例外情況是當您使用受 FairPlay 保護的視頻時，Apple 會阻止其鏡像（<a href="https://developer.apple.com/videos/play/wwdc2015/502/"> WWDC 2015，會議 502</a>）。</p>

<p>要顯示受 FairPlay 保護的視頻，請設置通過 Brightcove Playback Controller 公開的 AVPlayer 屬性，以允許 FairPlay 視頻在外部顯示器上播放。視頻以全屏模式播放。這是設置這些屬性的示例：</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab7">對象</a></li>
      <li><a href="#tab8">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab7" class="tab active">
       <pre class="line-numbers">
<code class="language-objectivec" translate="No">playbackController.allowsExternalPlayback = YES;
playbackController.usesExternalPlaybackWhileExternalScreenIsActive = YES;</code></pre>
      </div>
      <div id="tab8" class="tab">
        <pre>
<code class="language-swift" translate="No">playbackController.allowsExternalPlayback = true
playbackController.usesExternalPlaybackWhileExternalScreenIsActive = true</code></pre>
      </div>
    </div>
  </div>
  <!-- end tabs -->

  <h4>參考</h4>
  <p>有關詳細信息，請參見<a href="/ios/reference/sdk/Protocols/BCOVPlaybackController.html#//api/name/usesExternalPlaybackWhileExternalScreenIsActive">BCOVPlaybackController</a>文檔。</p>


</section>

<section class="bcls-section">
<h2 id="Google_Analytics">谷歌分析</h2>

<p>如果您使用Brightcove播放器和目錄類，則將自動收集視頻分析並將其顯示在“視頻雲分析"模塊中。有關其他指標，您可以將Google Analytics（分析）添加到您的應用中。</p>

<p>要將 Google Analytics 與您的應用程序集成，請按以下步驟操作：</p>

<ol class="bcls-tasklist-restart">
	<li>查看 Google 的文檔以<a href="https://developers.google.com/analytics/devguides/collection/ios/v3/#get-config">將分析添加到您的 iOS 應用程序</a> .</li>
	<li>
	<p>您可以通過以下一種方法使用Google Analytics（分析）來通過Google的Firebase SDK跟踪視頻播放：</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab9">對象</a></li>
      <li><a href="#tab10">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab9" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">// This snippet shows one way to track video playback
// using the Firebase SDK from Google Analytics with
// the lifecycle event playback controller delegate method.
- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didReceiveLifecycleEvent:(BCOVPlaybackSessionLifecycleEvent *)lifecycleEvent
{
	// Common parameters
	NSString *video_name = session.video.properties[kBCOVVideoPropertyKeyName];
	NSString *video_ID = session.video.properties[kBCOVVideoPropertyKeyId];

	// Session is ready to play
	if ([kBCOVPlaybackSessionLifecycleEventReady isEqualToString:lifecycleEvent.eventType])
	{
		[FIRAnalytics logEventWithName:@&quot;bcov_video_ready&quot;
	    parameters:@{
	        @&quot;bcov_video_name&quot;: video_name,
	        @&quot;bcov_video_id&quot;: video_ID
	    }];
	}

	// Session encountered an error
	if ([kBCOVPlaybackSessionLifecycleEventError isEqualToString:lifecycleEvent.eventType])
	{
		NSError *error = lifecycleEvent.properties[kBCOVPlaybackSessionEventKeyError];
		int error_code = error.code;
		[FIRAnalytics logEventWithName:@&quot;bcov_video_playback_error&quot;
	    parameters:@{
	        @&quot;bcov_video_name&quot;: video_name,
	        @&quot;bcov_video_id&quot;: video_ID,
	        @&quot;bcov_video_error_code&quot;: @(error_code)
	    }];
	}

	// Session has completed
	if ([kBCOVPlaybackSessionLifecycleEventTerminate isEqualToString:lifecycleEvent.eventType])
	{
		[FIRAnalytics logEventWithName:@&quot;bcov_video_terminate&quot;
	    parameters:@{
	        @&quot;bcov_video_name&quot;: video_name,
	        @&quot;bcov_video_id&quot;: video_ID
	     }];
	}
}</code></pre>
      </div>
      <div id="tab10" class="tab">
        <pre>
<code class="language-swift" translate="No">// This snippet shows one way to track video playback
// using the Firebase SDK from Google Analytics with
// the lifecycle event playback controller delegate method.
func playbackController(_ controller: BCOVPlaybackController!, playbackSession session: BCOVPlaybackSession!, didReceive lifecycleEvent: BCOVPlaybackSessionLifecycleEvent!) {
        
    // Common parameters
    let video_name = session.video.properties[kBCOVVideoPropertyKeyName]
    let video_id = session.video.properties[kBCOVVideoPropertyKeyId]
    
    // Session is ready to play
    if (lifecycleEvent.eventType == kBCOVPlaybackSessionLifecycleEventReady) {
        
        if let video_name = video_name as? String, let video_id = video_id as? String {
            Analytics.logEvent(&quot;bcov_video_ready&quot;, parameters: [
                &quot;bcov_video_name&quot; : video_name,
                &quot;bcov_video_id&quot; : video_id
            ])
        }
        
    }
    
    // Session encountered an error
    if (lifecycleEvent.eventType == kBCOVPlaybackSessionLifecycleEventError) {
     
        if let error = lifecycleEvent.properties[kBCOVPlaybackSessionEventKeyError] as? NSError {
            let error_code = error.code
            
            if let video_name = video_name as? String, let video_id = video_id as? String {
                Analytics.logEvent(&quot;bcov_video_playback_error&quot;, parameters: [
                    &quot;bcov_video_name&quot; : video_name,
                    &quot;bcov_video_id&quot; : video_id,
                    &quot;bcov_video_error_code&quot; : error_code
                ])
            }
        }
        
    }
    
    // Session has completed
    if (lifecycleEvent.eventType == kBCOVPlaybackSessionLifecycleEventTerminate) {
        
        if let video_name = video_name as? String, let video_id = video_id as? String {
            Analytics.logEvent(&quot;bcov_video_terminate&quot;, parameters: [
                &quot;bcov_video_name&quot; : video_name,
                &quot;bcov_video_id&quot; : video_id
            ])
        }
        
    }

}</code></pre>
      </div>
    </div>
  </div>
  <!-- end tabs -->
	</li>
</ol>

<p>&nbsp;</p>
</section>

<section class="bcls-section">
<h2 id="Limiting_the_bitrate">限制比特率</h2>

<p>您無法控制 HLS 清單中的哪個源（呈現）被<code translate="No">AVPlayer </code>，但您可以對播放設置比特率上限。這可以防止播放器使用比特率超過指定比特率的源（再現）。</p>

<p>設置<code translate="No">preferredPeakBitRate </code>到給定網絡帶寬消耗的所需限制（以每秒位數為單位）<code translate="No">AVPlayerItem </code> .</p>

<p>使用以下聲明之一：</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab11">對象</a></li>
      <li><a href="#tab12">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab11" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">[self.playbackController setPreferredPeakBitRate:1000];</code></pre>
      </div>
      <div id="tab12" class="tab">
        <pre>
<code class="language-swift" translate="No">playbackController.setPreferredPeakBitRate(1000)</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

</section>

<section class="bcls-section">
<h2 id="Looping_a_video">循環播放視頻</h2>

<p>在某些情況下，您可能希望視頻自動重播。為此，您可以獲得“視頻結束”生命週期事件，尋找開始並再次播放。</p>

<p>此代碼假定您已使用此方法將播放控制器的委託設置為對象：</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab13">對象</a></li>
      <li><a href="#tab14">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab13" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didReceiveLifecycleEvent:(BCOVPlaybackSessionLifecycleEvent *)lifecycleEvent
{
	if ([kBCOVPlaybackSessionLifecycleEventEnd isEqualToString:lifecycleEvent.eventType])
	{
		[controller seekToTime:kCMTimeZero completionHandler:^(BOOL finished) {
			if (finished)
			{
				[controller play];
			}
		}];
	}
}</code></pre>
      </div>
      <div id="tab14" class="tab">
        <pre>
<code class="language-swift" translate="No">func playbackController(_ controller: BCOVPlaybackController!, playbackSession session: BCOVPlaybackSession!, didReceive lifecycleEvent: BCOVPlaybackSessionLifecycleEvent!) {
        
    if (lifecycleEvent.eventType == kBCOVPlaybackSessionLifecycleEventEnd) {
        controller.seek(to: CMTime.zero) { (finished: Bool) in
            if (finished) {
                controller.play()
            }
        }
    }
    
}</code></pre>
      </div>
    </div>
  </div>
  <!-- end tabs -->

</section>

<section class="bcls-section">
<h2 id="Managing_videos_in_a_playlist">管理播放列表中的視頻</h2>

<p>管理視頻播放列表的一種方法是將視頻對象存儲在表中。當用戶從表中選擇視頻時，表行將包含視頻對象。</p>

<p>以下是其工作原理的概述：</p>

<ol class="bcls-tasklist-restart">
	<li>
	<p>從您的帳戶中檢索播放列表。</p>

  <!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab15">對象</a></li>
      <li><a href="#tab16">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab15" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">- (void)retrievePlaylist
{
	[self.refreshControl beginRefreshing];

	// Retrieve a playlist through the BCOVPlaybackService
	BCOVPlaybackServiceRequestFactory *playbackServiceRequestFactory = [[BCOVPlaybackServiceRequestFactory alloc]         
  initWithAccountId:kDynamicDeliveryAccountID
	policyKey:kDynamicDeliveryPolicyKey];
	BCOVPlaybackService *playbackService = [[BCOVPlaybackService alloc] initWithRequestFactory:playbackServiceRequestFactory];

	[playbackService findPlaylistWithReferenceID:kDynamicDeliveryPlaylistRefID parameters:nil 
  completion:^(BCOVPlaylist *playlist, NSDictionary *jsonResponse, NSError *error) 
	{
		[self.refreshControl endRefreshing];

		NSLog(@&quot;JSON Response:\n%@&quot;, jsonResponse);

		if (playlist)
		{
			self.currentVideos = playlist.videos.mutableCopy;
			self.currentPlaylistTitle = playlist.properties[@&quot;name&quot;];
			self.currentPlaylistDescription = playlist.properties[@&quot;description&quot;];

			NSLog(@&quot;Retrieved playlist containing %d videos&quot;, (int)self.currentVideos.count);

			[self usePlaylist:self.currentVideos];
		}
		else
		{
			NSLog(@&quot;No playlist for ID %@ was found.&quot;, kDynamicDeliveryPlaylistRefID);
		}

	}];
}</code></pre>
      </div>
      <div id="tab16" class="tab">
        <pre>
<code class="language-swift" translate="No">func retrievePlaylist() {
    refreshControl.beginRefreshing()
    
    let playbackServiceRequestFactory = BCOVPlaybackServiceRequestFactory(accountId: kDynamicDeliveryAccountID, policyKey: kDynamicDeliveryPolicyKey)
    let playbackService = BCOVPlaybackService(requestFactory: playbackServiceRequestFactory)
    
    playbackService?.findPlaylist(withPlaylistID: kDynamicDeliveryPlaylistRefID, parameters: nil, completion: { [weak self] (playlist: BCOVPlaylist?, jsonResponse: [AnyHashable:Any]?, error: Error?) in
        
        guard let strongSelf = self else {
            return
        }
        
        strongSelf.refreshControl.endRefreshing()
        
        if let playlist = playlist {
            strongSelf.currentVideos = playlist.videos
            strongSelf.currentPlaylistTitle = playlist.properties[&quot;name&quot;] as? String ?? &quot;&quot;
            strongSelf.currentPlaylistDescription = playlist.properties[&quot;description&quot;] as? String ?? &quot;&quot;
            
            print(&quot;Retrieved playlist containing \(playlist.videos.count) videos&quot;)
            
            strongSelf.usePlaylist(playlist)
        } else {
            print(&quot;No playlist for ID \(kDynamicDeliveryPlaylistRefID) was found.&quot;);
        }
        
    })
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

	</li>
	<li>
	<p>重新初始化用於在當前播放列表中存儲與視頻相關的信息的容器。</p>
	</li>
	<li>
	<p>當表格視圖被選中時，該行的索引用於創建一個新的<code translate="No">videoDictionary</code> .接下來，向字典詢問視頻。如果視頻不為空，則將視頻加載到<code translate="No">playbackController</code>。</p>

  <!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab17">對象</a></li>
      <li><a href="#tab18">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab17" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">// Play the video in this row when selected
- (IBAction)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(nonnull NSIndexPath *)indexPath
{
	NSDictionary *videoDictionary = self.videosTableViewData[ (int)indexPath.row ];
	BCOVVideo *video = videoDictionary[@&quot;video&quot;];

	if (video != nil)
	{
		[self.playbackController setVideos:@[ video ]];
	}
}</code></pre>
      </div>
      <div id="tab18" class="tab">
        <pre>
<code class="language-swift" translate="No">func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        
    guard let videosTableViewData = videosTableViewData, 
    let videoDictionary = videosTableViewData[indexPath.row] as? 
    [AnyHashable:Any], let video = videoDictionary[&quot;video&quot;] as? BCOVVideo else {
        return
    }
    
    playbackController.setVideos([video] as NSFastEnumeration)
    
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

	</li>
</ol>

<p>要使用播放列表，您可以將播放列表存儲在另一個對象（例如表格）中。基於用戶交互，您可以導航對象的索引並選擇適當的視頻。</p>

<aside class="bcls-aside bcls-aside--tip">有關完整的代碼示例，請參閱<a href="https://github.com/BrightcoveOS/ios-player-samples/tree/master/Offline">離線播放器</a>樣本。</aside>
</section>

<section class="bcls-section">
<h2 id="Media_progress_values">媒體進度值</h2>

<p>在媒體播放期間，報告給Player SDK進度委託方法的值可能包括負無窮大的初始值和正無窮大的最終值。這些值在處理前貼片廣告和後貼片廣告時使用。</p>

<p>如果這些值對您不重要或乾擾您自己的進度跟踪，則可以使用如下條件語句輕鬆忽略它們：</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab19">對象</a></li>
      <li><a href="#tab20">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab19" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didProgressTo:(NSTimeInterval)progress
{
	if (progress &lt; 0.0 || progress &gt;= INFINITY)
	{
		return;
	}

	// Your code here
}</code></pre>
      </div>
      <div id="tab20" class="tab">
        <pre>
<code class="language-swift" translate="No">func playbackController(_ controller: BCOVPlaybackController!, playbackSession session: BCOVPlaybackSession!, didProgressTo progress: TimeInterval) {
        
    if (progress &lt; 0.0 || progress &gt;= Double.infinity) {
        return;
    }
    
    // Your code here
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

<h4>參考</h4>
  <p>有關詳細信息，請參見<a href="/ios/reference/sdk/Protocols/BCOVPlaybackControllerBasicDelegate.html#//api/name/playbackController:playbackSession:didProgressTo:">BCOVPlaybackController</a>文檔。</p>

</section>

<section class="bcls-section">
  <h2 id="Modifying_captions_programmatically">以編程方式修改字幕</h2>
  <p>您可以在播放過程中隨時設置字幕<code translate="No">Ready</code>事件已收到。為此，您可以使用<a href="/ios/reference/sdk/Protocols/BCOVPlaybackControllerDelegate.html">BCOVPlaybackControllerDelegate</a> .</p>
  
  <p>這是將字幕語言設置為西班牙語的示例：</p>
  
    <!-- tabs -->
    <div class="tabs">
      <ul class="tab-links">
        <li class="active"><a href="#tab35">對象</a></li>
        <li><a href="#tab36">迅速</a></li>
      </ul>
  
      <div class="tab-content">
        <div id="tab35" class="tab active">
         <pre class="line-numbers">
<code class="language-objectivec" translate="No">- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didReceiveLifecycleEvent:(BCOVPlaybackSessionLifecycleEvent *)lifecycleEvent
  {
      if ([kBCOVPlaybackSessionLifecycleEventReady isEqualToString:lifecycleEvent.eventType])
      {
          AVMediaSelectionGroup *legibleMediaSelectionGroup = session.legibleMediaSelectionGroup;
          NSArray&lt;AVMediaSelectionOption *&gt; *options = [AVMediaSelectionGroup mediaSelectionOptionsFromArray:legibleMediaSelectionGroup.options withLocale:[NSLocale localeWithLocaleIdentifier:@&quot;es&quot;]];
          AVMediaSelectionOption *option = options.firstObject;
          session.selectedLegibleMediaOption = option;
      }
  }</code></pre>
        </div>
        <div id="tab36" class="tab">
          <pre>
<code class="language-swift" translate="No">func playbackController(_ controller: BCOVPlaybackController?, playbackSession session: BCOVPlaybackSession?, didReceive lifecycleEvent: BCOVPlaybackSessionLifecycleEvent?) {
    if kBCOVPlaybackSessionLifecycleEventReady == lifecycleEvent?.eventType {
        if let legibleMediaSelectionGroup = session?.legibleMediaSelectionGroup.options {
            let locale = NSLocale(localeIdentifier: &quot;es&quot;) as Locale
            let mediaSelectionOptions = AVMediaSelectionGroup.mediaSelectionOptions(from: legibleMediaSelectionGroup, with: locale)
            let mediaSelectionOption = mediaSelectionOptions.first
            session?.selectedLegibleMediaOption = mediaSelectionOption
        }
    }
}</code></pre>
        </div>
      </div>
    </div>
    <!-- end tabs -->
  </section>

<section class="bcls-section">
<h2 id="Paging_with_the_Playback_API">使用播放API分頁</h2>

<p>從 Playback API 檢索您的 Video Cloud 內容時，您可以為播放列表實現分頁。</p>

<p>要瀏覽播放列表中的一組視頻，請使用以下請求 URL 參數：</p>

<ul>
	<li><code translate="No"><a href="https://apis.support.brightcove.com/playback/getting-started/overview-playback-api.html#playlistRequests">limit</a> </code> -定義要從Playback API返回的視頻數</li>
	<li><code translate="No"><a href="https://apis.support.brightcove.com/playback/getting-started/overview-playback-api.html#playlistRequests">offset</a> </code> -設置要從Playback API播放列表中跳過的視頻數</li>
</ul>

<p>此示例返回從播放列表中的第 10 個視頻開始的 6 個視頻：</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab21">對象</a></li>
      <li><a href="#tab22">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab21" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">NSDictionary *params = @{
	@&quot;limit&quot;: @6,
	@&quot;offset&quot;: @9
};

[playbackService findPlaylistWithReferenceID:playlistRefID parameters:params completion:^(BCOVPlaylist *playlist, NSDictionary *jsonResponse, NSError *error)
{ 
    // Your code here
}];</code></pre>
      </div>
      <div id="tab22" class="tab">
        <pre>
<code class="language-swift" translate="No">let params = [
    &quot;limit&quot;: 6,
    &quot;offset&quot;: 9
]

playbackService?.findPlaylist(withPlaylistID: playlistRefID, parameters: params, completion: { (playlist: BCOVPlaylist?, jsonResponse: [AnyHashable:Any]?, error: Error?) in
    // Your code here
})</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

</section>

<section class="bcls-section">
<h2 id="Programmatically_adding_cue_points">以編程方式添加提示點</h2>

<p>Video Cloud 客戶可以使用 Video Cloud Studio 向視頻添加提示點，如<a href="https://studio.support.brightcove.com/media/working-cue-points-media-module.html">向視頻添加提示點</a>文檔。</p>

<p>您還可以以編程方式向視頻添加提示點。下面的代碼向從 Playback API 返回的視頻添加季度間隔提示點：</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab23">對象</a></li>
      <li><a href="#tab24">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab23" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">// programmatically add cue points to a video
- (void)requestContentFromPlaybackService
{
    [self.service findVideoWithVideoID:kViewControllerVideoID parameters:nil completion:^(BCOVVideo *video, NSDictionary *jsonResponse, NSError *error) {
        if (video)
        {
            // Get the video duration from the properties dictionary
            NSNumber *durationNumber = video.properties[@&quot;duration&quot;]; // milliseconds
            float duration = durationNumber.floatValue / 1000.0; // convert to seconds
            video = [video update:^(id&lt;BCOVMutableVideo&gt; mutableVideo)
            {
                // Add quarterly interval cue points of your own type
                BCOVCuePoint *cp1 = [[BCOVCuePoint alloc] initWithType:@&quot;<span class="bcls-input">your cue point type</span>&quot; position:CMTimeMake(duration * 250, 1000)];
                BCOVCuePoint *cp2 = [[BCOVCuePoint alloc] initWithType:@&quot;<span class="bcls-input">your cue point type</span>&quot; position:CMTimeMake(duration * 500, 1000)];
                BCOVCuePoint *cp3 = [[BCOVCuePoint alloc] initWithType:@&quot;<span class="bcls-input">your cue point type</span>&quot; position:CMTimeMake(duration * 750, 1000)];
                BCOVCuePoint *cp4 = [[BCOVCuePoint alloc] initWithType:@&quot;<span class="bcls-input">your cue point type</span>&quot; position:CMTimeMake(duration * 1000, 1000)];
                // Create new cue point collection using existing cue points and new cue points
                NSMutableArray *newCuePoints = [[NSMutableArray alloc] initWithArray:mutableVideo.cuePoints.array];
                [newCuePoints addObject:cp1];
                [newCuePoints addObject:cp2];
                [newCuePoints addObject:cp3];
                [newCuePoints addObject:cp4];
                mutableVideo.cuePoints = [[BCOVCuePointCollection alloc] initWithArray:newCuePoints];
            }];
                
            [self.playbackController setVideos:@[ video ]];
        }
        else
        {
            NSLog(@&quot;ViewController Debug - Error retrieving video: `%@`&quot;, error);
        }
    }];
}</code></pre>
      </div>
      <div id="tab24" class="tab">
        <pre>
<code class="language-swift" translate="No">// programmatically add cue points to a video
func requestContentFromPlaybackService() {
    playbackService?.findVideo(withVideoID: kViewControllerVideoID, parameters: nil) 
    { [weak self] (video: BCOVVideo?, jsonResponse: [AnyHashable: Any]?, error: Error?) -&gt; Void in

        if let error = error {
            print(&quot;ViewController Debug - Error retrieving video: `\(error.localizedDescription)`&quot;)
        }
        
        if let video = video {
            
            // Get the video duration from the properties dictionary
            guard let durationNumber = video.properties[&quot;duration&quot;] as? NSNumber else {
                return
            }
            
            let duration = durationNumber.floatValue / 1000.0; // convert to seconds
            
            let updatedVideo = video.update({ (mutableVideo: BCOVMutableVideo?) in
                
                guard let mutableVideo = mutableVideo else {
                    return
                }
                
                // Add quarterly interval cue points of your own type
                let cp1Position = CMTimeMake(value: Int64(duration * 250), timescale: 1000)
                let cp1 = BCOVCuePoint(type: &quot;<span class="bcls-input">your cue point type</span>&quot;, position: cp1Position)!
                let cp2Position = CMTimeMake(value: Int64(duration * 500), timescale: 1000)
                let cp2 = BCOVCuePoint(type: &quot;<span class="bcls-input">your cue point type</span>&quot;, position: cp2Position)!
                let cp3Position = CMTimeMake(value: Int64(duration * 750), timescale: 1000)
                let cp3 = BCOVCuePoint(type: &quot;<span class="bcls-input">your cue point type</span>&quot;, position: cp3Position)!
                let cp4Position = CMTimeMake(value: Int64(duration * 1000), timescale: 1000)
                let cp4 = BCOVCuePoint(type: &quot;<span class="bcls-input">your cue point type</span>&quot;, position: cp4Position)!
                
                // Create new cue point collection using existing cue points and new cue points
                var newCuePoints = [BCOVCuePoint]()
                newCuePoints.append(cp1)
                newCuePoints.append(cp2)
                newCuePoints.append(cp3)
                newCuePoints.append(cp4)
                
                mutableVideo.cuePoints = BCOVCuePointCollection(array: newCuePoints)
            })
            
            self?.playbackController.setVideos([updatedVideo] as NSFastEnumeration)
        }
        
    }
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

<p>&nbsp;</p>
<p>請注意，<code translate="No">your cue point type </code>可以是您想要的任何字符串值，只要您不使用任何<a href="/ios/basics/overview-brightcove-player-sdk-ios.html#Integrations">iOS插件</a>。有關詳細信息，請參見<a href="/ios/reference/sdk/Protocols/BCOVCuePoint.html#//api/name/type">BCOVCuePoint協議參考</a>文檔。</p>

<p>如果您通過IMA插件使用提示點，請在<a href="https://github.com/brightcove/brightcove-player-sdk-ios-ima#vast-and-vmapserver-side-ad-rules">VAST和VMAP /服務器端廣告規則</a>適用於iOS的Native SDK的IMA插件部分。這<a href="https://github.com/brightcove/brightcove-player-sdk-ios-ima/blob/06bb6f8dff6075340737017a966ad19b20bf6adb/ios/BrightcoveIMA.framework/Headers/BCOVIMAComponent.h#L39-L42">IMA 示例應用</a>顯示 IMA 廣告提示點所需的值。</p>

<p>下面的代碼偵聽您的提示點並顯示一條消息：</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab25">對象</a></li>
      <li><a href="#tab26">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab25" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">// listen for cue points and display them
-(void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didPassCuePoints:(NSDictionary *)cuePointInfo
{
    BCOVCuePointCollection *cpc = cuePointInfo[@&quot;kBCOVPlaybackSessionEventKeyCuePoints&quot;];
    for (BCOVCuePoint *cp in cpc.array)
    {
        if ([cp.type isEqualToString:@&quot;<span class="bcls-input">your cue point type</span>&quot;])
        {
            NSLog(@&quot;Found your cue point at %f&quot;, CMTimeGetSeconds(cp.position));
        }
    }
}</code></pre>
      </div>
      <div id="tab26" class="tab">
        <pre>
<code class="language-swift" translate="No">// listen for cue points and display them
func playbackController(_ controller: BCOVPlaybackController!, playbackSession session: BCOVPlaybackSession!, didPassCuePoints cuePointInfo: [AnyHashable : Any]!) {
    if let cpc = cuePointInfo[kBCOVPlaybackSessionEventKeyCuePoints] as? BCOVCuePointCollection {
        for cp in cpc.array() {
            if let cp = cp as? BCOVCuePoint {
                if (cp.type == &quot;<span class="bcls-input">your cue point type</span>&quot;) {
                    print(&quot;Found your cue point at \(CMTimeGetSeconds(cp.position))&quot;)
                }
            }
        }
    }
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

<h4>參考</h4>
  <p>有關詳細信息，請參見以下內容：</p>
  <ul>
    <li><a href="/ios/reference/sdk/Protocols/BCOVVideo.html">BCOV視頻</a>文件資料</li>
     <li><a href="/ios/reference/sdk/Protocols/BCOVCuePoint.html">BCOVCuePoint</a>文件資料</li>
  </ul>
</section>
<!-- <section class="bcls-section" id="Setting_the_buffer_size">
		<h2>Setting the buffer size</h2>
		<p>You may consider increasing the buffer length to eliminate buffering in the player if the delivery of the next segment is delayed from the CDN. But, you may not be able to do anything better manually that HLS already does.</p>
		<p>The <code translate="No">AVPlayer</code> contains the <code translate="No">AVPlayerItem</code>, essentially the video being played, that contains the <code translate="No">loadedTimeRanges</code> property. This tells you how much is buffered.</p>
		<p>HLS is designed to play right away and drop quality if it can't keep up. This way, it does not need to preload a buffer. If it can't keep up, it will load as much of the video as it can at the best quality to prevent interruption.</p>
		</section> -->

<section class="bcls-section">
<h2 id="Removing_the_player">卸下播放器</h2>

<p>在某些情況下，您可能想要移除播放器和視圖。</p>
<p>
  取消分配擁有所有權的視圖控制器<code translate="No">BCOVPlaybackController</code>也會取消分配播放控制器。為此，請從其超視圖中刪除播放器視圖並將其播放控制器指針設置為<code translate="No">nil</code> .
</p>
<p>
  這是一個代碼示例：
</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab27">對象</a></li>
      <li><a href="#tab28">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab27" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">[self.playerView removeFromSuperview];
self.playerView = nil;
self.playbackController = nil;</code></pre>
      </div>
      <div id="tab28" class="tab">
        <pre>
<code class="language-swift" translate="No">playerView?.removeFromSuperview()
playerView = nil
playbackController = nil</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

</section>

<section class="bcls-section">
  <h2 id="Setting_audio_behavior">設置音頻行為</h2>
  
  <p>音頻會話處理應用級別的音頻行為。您可以從多個音頻會話類別和設置中進行選擇，以自定義應用的音頻行為。</p>
  <p>選擇最佳的音頻會話類別為您的應用。有關詳細信息，請查看 Apple 的文檔：</p>
  <ul>
    <li><a href="https://developer.apple.com/documentation/avfaudio/avaudiosession">AVAudioSession 類</a></li>
    <li>AVAudioSessionCategory<a href="https://developer.apple.com/documentation/avfaudio/avaudiosessioncategory"></a></li>
  </ul>
  <h3>基本樣品</h3>
  <p>對於我們的基本示例，我們使用<code translate="No">AVAudioSessionCategoryPlayback</code> .即使在屏幕被鎖定並且鈴聲/靜音開關設置為靜音時，它也會播放音頻。為簡單起見，我們將其代碼放在 App Delegate 中。</p>
  <!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab37">對象</a></li>
      <li><a href="#tab38">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab37" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">NSError *categoryError = nil;
  BOOL success = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:&amp;categoryError];
  if (!success)
  {
      // Handle error
  }</code></pre>
      </div>
      <div id="tab38" class="tab">
        <pre>
<code class="language-swift" translate="No">var categoryError :NSError?
  var success: Bool
  do {
      try AVAudioSession.sharedInstance().setCategory(.playback)
      success = true
  } catch let error as NSError {
      categoryError = error
      success = false
  }
  if !success {
      // Handle error
  }</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

  <h3>與其他音頻混合</h3>
  <p>當您的應用程序中的音頻靜音時，您可能希望允許聽到來自其他應用程序的音頻。為此，您可以配置<code translate="No">AVAudioSession</code>在可以訪問您當前的視圖控制器中<code translate="No">AVPlayer</code> .</p>
  <p>有關詳細信息，請參閱<a href="https://developer.apple.com/documentation/avfaudio/avaudiosession/categoryoptions/1616611-mixwithothers">混搭</a>類別選項。</p>
  <!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab39">對象</a></li>
      <li><a href="#tab40">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab39" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">- (void)setUpAudioSession
  {
      NSError *categoryError = nil;
      BOOL success;
      
      // If the player is muted, then allow mixing.
      // Ensure other apps can have their background audio active when this app is in foreground
      if (self.currentPlayer.isMuted)
      {
          success = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback withOptions:AVAudioSessionCategoryOptionMixWithOthers error:&amp;categoryError];
      }
      else
      {
          success = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback withOptions:0 error:&amp;categoryError];
      }
      
      if (!success)
      {
          NSLog(@&quot;AppDelegate Debug - Error setting AVAudioSession category.  Because of this, there may be no sound. `%@`&quot;, categoryError);
      }
  }</code></pre>
      </div>
      <div id="tab40" class="tab">
        <pre>
<code class="language-swift" translate="No">func setUpAudioSession() {
  var categoryError :NSError?
  var success: Bool
  do {
      if let currentPlayer = currentPlayer {
          // If the player is muted, then allow mixing.
          // Ensure other apps can have their background audio active when this app is in foreground
          if currentPlayer.isMuted {
              try AVAudioSession.sharedInstance().setCategory(.playback, options: .mixWithOthers)
          } else {
              try AVAudioSession.sharedInstance().setCategory(.playback, options: AVAudioSession.CategoryOptions(rawValue: 0))
          }
      } else {
          try AVAudioSession.sharedInstance().setCategory(.playback, options: AVAudioSession.CategoryOptions(rawValue: 0))
      }
      
      success = true
  } catch let error as NSError {
      categoryError = error
      success = false
  }
  if !success {
      print(&quot;AppDelegate Debug - Error setting AVAudioSession category.  Because of this, there may be no sound. \(categoryError!)&quot;)
  }
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->
  
  </section>

<section class="bcls-section">
<h2 id="Setting_the_playback_rate">設置播放速率</h2>

<p>要控製播放速率，您可以設置<code translate="No">rate </code>上的財產<code translate="No">AVPlayer </code>在會話中公開的類。</p>

<p>默認情況下，只能以固定間隔（0.50、0.67、1.0、1.25、1.50和2.0）設置播放速率。通過設置<a href="https://developer.apple.com/documentation/avfoundation/avaudiotimepitchalgorithm">audioTimePitchAlgorithm</a>，則可以使用更精細的費率值（例如1.7）。有關更多詳細信息，請參見此<a href="https://stackoverflow.com/questions/6630356/avplayer-rate-property-does-not-work">stackoverflow討論</a>。</p>

<pre>
<code class="language-objectivec" translate="No">avPlayerItem.audioTimePitchAlgorithm = AVAudioTimePitchAlgorithmVarispeed;</code></pre>

<aside class="bcls-aside bcls-aside--information">
  <p>
    即使此示例使用了<code translate="No">varispeed</code>物業類型<a href="https://developer.apple.com/documentation/avfoundation/avaudiotimepitchalgorithm">AVAudioTimePitchAlgorithm</a>類具有4個可以使用的屬性類型：
  </p>
  <ul>
    <li>
      <a href="https://developer.apple.com/documentation/avfoundation/avaudiotimepitchalgorithm/1621212-lowqualityzerolatency">低質量零延遲</a>
    </li>
    <li>
      <a href="https://developer.apple.com/documentation/avfoundation/avaudiotimepitchalgorithm/1388153-spectral">光譜</a>
    </li>
    <li>
      <a href="https://developer.apple.com/documentation/avfoundation/avaudiotimepitchalgorithm/1387220-timedomain">時域</a>
    </li>
    <li>
      <a href="https://developer.apple.com/documentation/avfoundation/avaudiotimepitchalgorithm/1387887-varispeed">變速</a>
    </li>
  </ul>
  <p>
    請注意<code translate="No">varispeed</code>選項不提供音高校正。這可能會導致音頻以高播放速率（例如 1.7）出現不自然的高音。選擇最適合您需求的屬性選項。
  </p>
</aside>

<p>為一個<code translate="No">BCOVPlaybackSession </code>，您的代碼將類似於以下內容：</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab29">對象</a></li>
      <li><a href="#tab30">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab29" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller
  playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didReceiveLifecycleEvent:(BCOVPlaybackSessionLifecycleEvent *)lifecycleEvent
{
    if ( [lifecycleEvent.eventType isEqualToString:kBCOVPlaybackSessionLifecycleEventReady] )
    {
        NSLog(@&quot;%@ at time %f&quot;, kBCOVPlaybackSessionLifecycleEventReady, CMTimeGetSeconds([session.player currentTime]));
        AVPlayerItem *avPlayerItem = [session.player currentItem];
        avPlayerItem.audioTimePitchAlgorithm = AVAudioTimePitchAlgorithmVarispeed;
        session.player.rate = 1.7;
    }
}</code></pre>
      </div>
      <div id="tab30" class="tab">
        <pre>
<code class="language-swift" translate="No">func playbackController(_ controller: BCOVPlaybackController!, playbackSession session: BCOVPlaybackSession!, didReceive lifecycleEvent: BCOVPlaybackSessionLifecycleEvent!) {
    
    if (lifecycleEvent.eventType == kBCOVPlaybackSessionLifecycleEventReady) {
        let seconds = CMTimeGetSeconds(session.player.currentTime())
        print(&quot;kBCOVPlaybackSessionLifecycleEventReady at time \(seconds)&quot;)
        let avPlayerItem = session.player.currentItem
        avPlayerItem?.audioTimePitchAlgorithm = AVAudioTimePitchAlgorithm.varispeed
        session.player.rate = 1.7
    }
    
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

<p>&nbsp;</p>
<aside class="bcls-aside bcls-aside--information">適用於 iOS 的 Native SDK 不支持播放速率的負值（即我們不支持反向播放視頻）。
<!-- <p>Notes</p>
<ul>
  <li>For iOS6, a stream can only play at 2X if <code translate="No">session.player.currentItem.canPlayFastForward </code> returns <strong>YES</strong>.</li>
	<li>For iOS7, you can play up to 2X always, but it won't go higher unless <code translate="No">session.player.currentItem.canPlayFastForward </code> returns <strong>Yes</strong>.</li>
	<li>For more information about managing playback, see Apple's <a href="https://developer.apple.com/library/ios/documentation/AVFoundation/Reference/AVPlayer_Class/index.html#//apple_ref/occ/instp/AVPlayer/rate">AVPlayer Class Reference</a>.</li>
</ul> -->
</aside>
</section>

<section class="bcls-section">
<h2 id="Setting_VR_Goggles_mode_for_360_videos">為 360° 視頻設置 VR Goggles 模式</h2>

<p>播放 360° 視頻時，用戶可以選擇控制欄上的 Video 360 按鈕切換到 VR Goggles 模式。您可能還想在播放開始之前以編程方式執行此操作。您可以通過更新<code translate="No">BCOVPlaybackController </code>協議的<code translate="No">viewProjection </code>屬性如下：</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab31">對象</a></li>
      <li><a href="#tab32">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab31" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller didAdvanceToPlaybackSession:(id&lt;BCOVPlaybackSession&gt;)session
{
    BCOVVideo360ViewProjection *viewProjection = [self.playbackController.viewProjection copy];
    [viewProjection setProjectionStyle:BCOVVideo360ProjectionStyleVRGoggles];
    [self.playbackController setViewProjection:viewProjection];
}</code></pre>
      </div>
      <div id="tab32" class="tab">
        <pre>
<code class="language-swift" translate="No">func playbackController(_ controller: BCOVPlaybackController!, didAdvanceTo session: BCOVPlaybackSession!) {
    if let viewProjection: BCOVVideo360ViewProjection = controller.viewProjection.copy() as? BCOVVideo360ViewProjection {
        viewProjection.projectionStyle = BCOVVideo360ProjectionStyle.vrGoggles
        playbackController.viewProjection = viewProjection
    }
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

<p>&nbsp;</p>
<aside class="bcls-aside bcls-aside--information">請注意，您需要在<code translate="No">didAdvanceToPlaybackSession </code>委託方法。</aside>
</section>
<!-- <section class="bcls-section">
<h2 id="VoiceOver_support">VoiceOver support</h2>

<p>Apple's <a href="https://www.apple.com/accessibility/iphone/vision/">VoiceOver app</a>, which is integrated in iOS, allows visually impaired users to hear a description of everything that is on the screen.</p>

<p>The built-in playback controls for Brightcove Native SDK for iOS come with accessibility labels which have no default text values. If you want to take advantage of VoiceOver, you can add your own custom text values. The UIControl objects can be found in the following:</p>

<ul>
	<li>All the normal playback controls are found in the <a href="/ios/reference/sdk/Classes/BCOVPUIPlayerView.html#//api/name/controlsView">BCOVPUIBasicControlView *controlsView</a> property of the <a href="/ios/reference/sdk/Classes/BCOVPUIPlayerView.html">BCOVPUIPlayerView</a>.</li>
	<li>All of the ad controls are found in the <a href="/ios/reference/sdk/Classes/BCOVPUIPlayerView.html#//api/name/adControlsView">BCOVPUIAdControlView *adControlsView</a> property of the <a href="/ios/reference/sdk/Classes/BCOVPUIPlayerView.html">BCOVPUIPlayerView</a>.</li>
</ul>

<p>This example shows how to customize the accessibility values for the play button:</p>

<pre class="line-numbers">
<code class="language-objectivec" translate="No"><a href="/ios/reference/sdk/Classes/BCOVPUIPlayerView.html#//api/name/controlsView">// After creating the BCOVPUIPlayerView, store it in a playerView property
// Then set the accessibilityLabel and accessibilityHint properties
self.playerView.controlsView.playbackButton.accessibilityLabel = @"Playback Button";
self.playerView.controlsView.playbackButton.accessibilityHint = @"Play or pause the video";</a>
</code></pre>

<aside class="bcls-aside bcls-aside--information">If you are using your own playback controls, then you have to add VoiceOver support yourself.</aside>
</section> -->

<section class="bcls-section">
<h2 id="Changing_the_background_color">更改背景顏色</h2>

<p>在縱向模式下播放視頻時，您可能會注意到播放器頂部和下方有一個黑色邊框。播放器視圖是屏幕的大小，但視頻只佔播放器視圖中心的一小部分。視頻周圍的可見部分是播放器層的背景。</p>

<p>這是正常的<code translate="No">AVPlayer </code>行為。它會縮小視頻以使其適合播放器層，而其餘部分則是播放器層背景。</p>

<p>您可以使用以下代碼更改播放器圖層背景：</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active"><a href="#tab33">對象</a></li>
      <li><a href="#tab34">迅速</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab33" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller didAdvanceToPlaybackSession:(id&lt;BCOVPlaybackSession&gt;)session
{
    session.playerLayer.backgroundColor = UIColor.whiteColor.CGColor;
}</code></pre>
      </div>
      <div id="tab34" class="tab">
        <pre>
<code class="language-swift" translate="No">func playbackController(_ controller: BCOVPlaybackController!, didAdvanceTo session: BCOVPlaybackSession!) {
    session.playerLayer.backgroundColor = UIColor.white.cgColor
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

<p>&nbsp;</p>
<p>將背景顏色設置為白色應如下所示：</p>

<figure class="bcls-figure"><img class="bcls-image--no-border" alt="Background color" src="//learning-services-media.brightcove.com/doc-assets/device-sdks/ios/snippets/ios-bkgd-color.png" />
<figcaption class="bcls-caption--image">自定義背景色</figcaption>
</figure>
</section>
</article>